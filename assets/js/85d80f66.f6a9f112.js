"use strict";(self.webpackChunkminjunsz_github_io=self.webpackChunkminjunsz_github_io||[]).push([[613],{1670:t=>{t.exports=JSON.parse('{"blogPosts":[{"id":"factory-method-pattern","metadata":{"permalink":"/programming/factory-method-pattern","source":"@site/programming/2023-01-09-factory-pattern.mdx","title":"[Design Pattern] Factory Method","description":"Factory method is a creational pattern which gives an interface for creating subclasses.","date":"2023-01-09T00:00:00.000Z","formattedDate":"January 9, 2023","tags":[{"label":"python","permalink":"/programming/tags/python"},{"label":"design-pattern","permalink":"/programming/tags/design-pattern"},{"label":"creational-pattern","permalink":"/programming/tags/creational-pattern"}],"readingTime":3.29,"hasTruncateMarker":true,"authors":[{"name":"Minjun Park","url":"https://github.com/minjunsz","imageURL":"https://github.com/minjunsz.png","key":"minjun"}],"frontMatter":{"title":"[Design Pattern] Factory Method","description":"Factory method is a creational pattern which gives an interface for creating subclasses.","slug":"factory-method-pattern","authors":["minjun"],"tags":["python","design-pattern","creational-pattern"],"hide_table_of_contents":false}},"content":"The factory method is a **creational pattern** which gives an interface for creating subclasses.\\nThis post will demonstrate a classical OOP pattern and a more pythonic factory pattern.\\n\\n\x3c!--truncate--\x3e\\n\\n## What is Factory Method Pattern?\\n\\nFactory method pattern is a creational design pattern that provides a high-level interface for creating a superclass object\\nbut allows subclasses to alter the type of objects created. Following is a high-level overview of the patterns:\\n\\n1. Define a superclass/interface of the subclasses.\\n2. Define an abstract method for creating a superclass object.\\n3. Each subclass implements the creation method above.\\n4. Program can alter the subclass object by altering the factory method.\\n\\n## Why do we Need Factory Pattern?\\n\\nSuppose we want to change the structure of a class. If we add a member variable, we will likely add an additional argument for the `__init__()` function.\\nIn most cases, **the creation process of an object is tightly coupled with the structure of the class**.\\nThis means that your program should depend on the concrete implementation, although you programmed based on an abstract interface.\\nTherefore, you want to separate the use from the creation.\\n\\n## Python Examples\\n\\n### Original Code\\n\\nThe example is code for logging a scalar value.\\nUsers can select which logger to use between \'tensorboard\' and \'wandb\'.\\nIn the original code, I introduced an abstract superclass `Logger.`\\nHowever, the `main()` function is still coupled with two concrete classes, `TensorboardLogger` and `WandbLogger`, in the conditional branches.\\n\\n\\n```python\\nfrom abc import ABC, abstractmethod\\n\\nclass Logger(ABC):\\n\\t@abstractmethod\\n\\tdef log_scalar(self, value: float) -> None:\\n\\t\\t...\\n\\nclass TensorboardLogger(Logger):\\n\\t...\\n\\nclass WandbLogger(Logger):\\n\\t...\\n\\ndef main() -> None:\\n\\t# select logger type\\n\\tlogger_name = input(\\"Enter logger type (tensorboard, wandb)\\")\\n\\n\\t# initialize logger\\n\\tlogger: Logger\\n\\tif logger_name == \\"tensorboard\\":\\n\\t\\tlogger = TensorboardLogger()\\n\\telif logger_name == \\"wandb\\":\\n\\t\\tlogger = WandbLogger()\\n\\telse\\n\\t\\traise ValueError\\n\\n\\t# log experiments\\n\\tlogger.log_scalar(0.5)\\n```\\n\\n### Factory Pattern using Superclass\\n\\nLet\'s define a corresponding factory interface and implement concrete factory classes for each logger.\\nIn this implementation, `main()` function is unaware of how to create concrete classes.\\nIt relies on abstract interfaces for both use and creation.\\n\\nIf you want to change the structure of a logger, it is enough to change the creation logic in its factory without modifying the `main()` function.\\n\\n```python\\nclass LoggerFactory(ABC):\\n\\t@abstractmethod\\n\\tdef get_logger(self) -> Logger:\\n\\t\\t...\\n\\nclass TensorboardLoggerFactory(ABC)\\n\\tdef get_logger(self) -> Logger:\\n\\t\\treturn TensorboardLogger()\\n\\nclass WandbLoggerFactory(ABC):\\n\\tdef get_logger(self) -> Logger:\\n\\t\\treturn WandbLogger()\\n\\ndef read_logger() -> LoggerFactory\\n\\tfactories = {\\n\\t\\t\\"tensorboard\\": TensorboardLoggerFactory(),\\n\\t\\t\\"wandb\\": WandbLoggerFactory()\\n\\t}\\n\\n\\t# select logger type\\n\\tlogger_name = input(\\"Enter logger type (tensorboard, wandb)\\")\\n\\n\\tif logger_name in factories:\\n\\t\\treturn factories[logger_name]\\n\\traise Exception(\\"Unknown logger type\\")\\n\\ndef main() -> None:\\n\\tfac = read_logger()\\n\\tlogger = fac.get_logger()\\n\\tlogger.log_scalar(0.5)\\n```\\n\\n### Factory Pattern using Protocol\\n\\nInheriting abstract classes introduces additional complexity, which comes from the class hierarchy. \\nIf the subclass does not reuse the parent\'s code and does not require a strict class hierarchy, it is preferable to use \'duck typing\' rather than an abstract base class.\\nHowever, the factory pattern relies on abstract base classes because classical programming languages do not support \'duck typing.\'\\nPython provides the `typing.Protocol` class for duck typing, so we can rewrite the code as follows.\\n\\n```python\\nfrom typing import Protocol\\n\\nclass Logger(Protocol):\\n\\tdef log_scalar(self, value: float) -> None:\\n\\t\\t...\\n\\nclass TensorboardLogger:\\n\\tdef log_scalar(self, value: float) -> None:\\n\\t\\t...\\n\\nclass WandbLogger:\\n\\tdef log_scalar(self, value: float) -> None:\\n\\t\\t...\\n\\nFACTORIES: dict[str, type[Logger]] = {\\n\\t\\"tensorboard\\": TensorboardLogger,\\n\\t\\"wandb\\": WandbLogger\\n}\\n\\ndef read_logger() -> Logger\\n\\twhile True:\\n\\t\\t# select logger type\\n\\t\\tlogger_name = input(\\"Enter logger type (tensorboard, wandb)\\")\\n\\t\\ttry:\\n\\t\\t\\tlogger_class = factories[logger_name]\\n\\t\\t\\treturn logger_class()\\n\\t\\texcept KeyError:\\n\\t\\t\\tprint(\\"Unknown logger type.\\")\\n\\ndef main() -> None:\\n\\tlogger = read_logger()\\n\\n\\t# log experiments\\n\\tlogger.log_scalar(0.5)\\n```\\n\\n## Class Diagram\\n\\n```mermaid\\nclassDiagram\\n    class Product\\n    <<interface>> Product\\n    Product : +doStuff()\\n    \\n    class ProductFactory\\n    <<interface>> ProductFactory\\n    ProductFactory : +createProduct() Product\\n    Product <.. ProductFactory\\n\\n    Product <|.. Product_A\\n    Product_A : +doStuff()\\n    Product <|.. Product_B\\n    Product_B : +doStuff()\\n\\n    ProductFactory <|.. ProductFactory_A\\n    ProductFactory_A : +createProduct() Product\\n    ProductFactory <|.. ProductFactory_B\\n    ProductFactory_B : +createProduct() Product\\n```"}]}')}}]);